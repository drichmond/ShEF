diff --git a/hdk/src/lib/stream/stream_write.sv b/hdk/src/lib/stream/stream_write.sv
index 04ebefc..6e24b7c 100644
--- a/hdk/src/lib/stream/stream_write.sv
+++ b/hdk/src/lib/stream/stream_write.sv
@@ -115,6 +115,8 @@ module stream_write #(
       localparam integer PMAC_DATA_WIDTH = 512;
     `elsif NUM_PMAC_PARALLEL_8
       localparam integer PMAC_DATA_WIDTH = 1024;
+    `elsif NUM_PMAC_PARALLEL_16
+      localparam integer PMAC_DATA_WIDTH = 2048;
     `endif
     localparam integer PMAC_DATA_WIDTH_BYTES = PMAC_DATA_WIDTH / 8;
     localparam integer PMAC_BURST_COUNT = 4096 / PMAC_DATA_WIDTH_BYTES;
@@ -212,6 +214,8 @@ module stream_write #(
   logic [AXI_DATA_WIDTH-1:0] mac_tag_burst;
   logic [AXI_WSTRB_WIDTH-1:0] mac_tag_wstrb;
 
+  logic axi_awvalid_r;
+
   //control
   logic cs_aes_req_val;
   logic cs_aes_resp_rdy;
@@ -223,6 +227,8 @@ module stream_write #(
   logic cs_req_addr_mux_sel;
   logic cs_axi_wdata_mux_sel;
   logic cs_m_axi_bready;
+  logic cs_axi_awvalid_r_val;
+  logic cs_axi_awvalid_r_we;
 
   //status
   logic ram_aes_fifo_empty;
@@ -483,7 +489,7 @@ module stream_write #(
 	  .FIFO_WRITE_DEPTH          (AXI_FIFO_DEPTH),   //positive integer
 	  .WRITE_DATA_WIDTH          (AXI_DATA_WIDTH),               //positive integer
 	  .WR_DATA_COUNT_WIDTH       ($clog2(AXI_FIFO_DEPTH)),               //positive integer, Not used
-	  .PROG_FULL_THRESH          (10),               //positive integer, Not used 
+	  .PROG_FULL_THRESH          (16),               //positive integer, Not used 
 	  .FULL_RESET_VALUE          (1),                //positive integer; 0 or 1
 	  .READ_MODE                 ("fwft"),            //string; "std" or "fwft";
 	  .FIFO_READ_LATENCY         (0),                //positive integer;
@@ -688,6 +694,13 @@ module stream_write #(
     .out(aes_axi_fifo_rd_en)
   );
 
+  shield_enreg #(.WIDTH(1)) axi_awvalid_reg(
+    .clk(clk),
+    .q(axi_awvalid_r),
+    .d(cs_axi_awvalid_r_val),
+    .en(cs_axi_awvalid_r_we)
+  );
+
 
   //////////////////////////////////////////////////////////////////////////////
   // Control logic
@@ -827,14 +840,15 @@ module stream_write #(
       end
       AXI_STATE_INIT_CRYPTO: begin //init crypto modules
         if((aes_req_rdy) && mac_req_rdy) begin
-          next_axi_state = AXI_STATE_WR_DATA_REQ;
-        end
-      end
-      AXI_STATE_WR_DATA_REQ: begin
-        if(m_axi_awready) begin
+          //next_axi_state = AXI_STATE_WR_DATA_REQ;
           next_axi_state = AXI_STATE_AES_ENCRYPT;
         end
       end
+      //AXI_STATE_WR_DATA_REQ: begin
+      //  if(m_axi_awready) begin
+      //    next_axi_state = AXI_STATE_AES_ENCRYPT;
+      //  end
+      //end
       AXI_STATE_AES_ENCRYPT: begin
         if((!aes_mac_fifo_full) && (!aes_axi_fifo_full) && (!ram_aes_fifo_empty) && (aes_resp_val)) begin
           next_axi_state = AXI_STATE_AES_REQ;
@@ -852,16 +866,17 @@ module stream_write #(
       end
       AXI_STATE_WRITE_DATA: begin
         if(axi_write_done && m_axi_bvalid) begin
-          next_axi_state = AXI_STATE_WR_TAG_REQ;
-        end
-      end
-      AXI_STATE_WR_TAG_REQ: begin
-        if(m_axi_awready) begin
+          //next_axi_state = AXI_STATE_WR_TAG_REQ;
           next_axi_state = AXI_STATE_WR_TAG;
         end
       end
+      //AXI_STATE_WR_TAG_REQ: begin
+      //  if(m_axi_awready) begin
+      //    next_axi_state = AXI_STATE_WR_TAG;
+      //  end
+      //end
       AXI_STATE_WR_TAG: begin
-        if(m_axi_wready && mac_tag_val) begin
+        if(m_axi_wready && m_axi_wvalid) begin
           next_axi_state = AXI_STATE_WR_TAG_RESP;
         end
       end
@@ -885,9 +900,16 @@ module stream_write #(
     cs_axi_wdata_mux_sel = 1'b0;
     cs_m_axi_bready = 1'b0;
 
+    cs_axi_awvalid_r_val = 1'b0;
+    cs_axi_awvalid_r_we = 1'b0;
+
     case (axi_state_r)
       AXI_STATE_IDLE: begin //wait for flush signal - store flush addr
         cs_flush_rdy = 1'b1;
+
+        // Clear awvalid flag
+        cs_axi_awvalid_r_val = 1'b0;
+        cs_axi_awvalid_r_we = 1'b1;
       end
       AXI_STATE_INIT_CRYPTO: begin
         if((aes_req_rdy) && mac_req_rdy) begin
@@ -895,38 +917,75 @@ module stream_write #(
           cs_mac_req_val = 1'b1;
         end
       end
-      AXI_STATE_WR_DATA_REQ: begin
-        cs_m_axi_awvalid = 1'b1;
-        cs_req_addr_mux_sel = 1'b0; //data address
-      end
+      //AXI_STATE_WR_DATA_REQ: begin
+      //  cs_m_axi_awvalid = 1'b1;
+      //  cs_req_addr_mux_sel = 1'b0; //data address
+      //end
       AXI_STATE_AES_ENCRYPT: begin
         if((!aes_mac_fifo_full) && (!aes_axi_fifo_full) && (!ram_aes_fifo_empty) && (aes_resp_val)) begin
           cs_aes_resp_rdy = 1'b1;
           cs_aes_out_fifo_we = 1'b1;
         end
         cs_axi_wdata_mux_sel = 1'b0;
+
+        // Set awvalid if not already done
+        cs_req_addr_mux_sel = 1'b0;
+        cs_req_wdata_mux_sel = 1'b0;
+        if ((axi_awvalid_r == 1'b0) && m_axi_wvalid && m_axi_awready) begin
+          cs_m_axi_awvalid = 1'b1;
+          cs_axi_awvalid_r_val = 1'b1;
+          cs_axi_awvalid_r_we = 1'b1;
+        end
       end
       AXI_STATE_AES_REQ: begin
         cs_axi_wdata_mux_sel = 1'b0;
         if(!aes_enc_done) begin
           cs_aes_req_val = 1'b1;
         end
+
+        // Set awvalid if not already done
+        cs_req_addr_mux_sel = 1'b0;
+        cs_req_wdata_mux_sel = 1'b0;
+        if ((axi_awvalid_r == 1'b0) && m_axi_wvalid && m_axi_awready) begin
+          cs_m_axi_awvalid = 1'b1;
+          cs_axi_awvalid_r_val = 1'b1;
+          cs_axi_awvalid_r_we = 1'b1;
+        end
       end
       AXI_STATE_WRITE_DATA: begin
-        cs_axi_wdata_mux_sel = 1'b0;
-        if(axi_write_done && m_axi_bvalid) begin
+        // Set awvalid if not already done
+        cs_req_addr_mux_sel = 1'b0;
+        cs_req_wdata_mux_sel = 1'b0;
+        if ((axi_awvalid_r == 1'b0) && m_axi_wvalid && m_axi_awready) begin
+          cs_m_axi_awvalid = 1'b1;
+          cs_axi_awvalid_r_val = 1'b1;
+          cs_axi_awvalid_r_we = 1'b1;
+        end
+        else if(axi_write_done && m_axi_bvalid) begin
           cs_m_axi_bready = 1'b1;
+
+          // Clear the awvalid reg
+          cs_axi_awvalid_r_val = 1'b0;
+          cs_axi_awvalid_r_we = 1'b1;
         end
       end
-      AXI_STATE_WR_TAG_REQ: begin
-        cs_axi_wdata_mux_sel = 1'b1;
-        cs_req_addr_mux_sel = 1'b1;
-        cs_m_axi_awvalid = 1'b1;
-      end
+      //AXI_STATE_WR_TAG_REQ: begin
+      //  cs_axi_wdata_mux_sel = 1'b1;
+      //  cs_req_addr_mux_sel = 1'b1;
+      //  cs_m_axi_awvalid = 1'b1;
+      //end
       AXI_STATE_WR_TAG: begin
         cs_axi_wdata_mux_sel = 1'b1;
         cs_req_addr_mux_sel = 1'b1;
-        if(m_axi_wready) begin
+
+        //ready to write
+        if ((axi_awvalid_r == 1'b0) && m_axi_wvalid && m_axi_awready) begin
+          // write addr
+          cs_m_axi_awvalid = 1'b1;
+          cs_axi_awvalid_r_val = 1'b1;
+          cs_axi_awvalid_r_we = 1'b1;
+        end
+        if(m_axi_wready && m_axi_wvalid) begin
           cs_mac_tag_rdy = 1'b1;
         end
       end
